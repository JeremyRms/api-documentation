<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>api-documentation test</title>
  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="amf-loader.js"></script>
  <link rel="import" href="../../arc-polyfills/arc-polyfills.html">
  <link rel="import" href="../api-documentation.html">
</head>

<body>
  <test-fixture id="Basic">
    <template>
      <api-documentation></api-documentation>
    </template>
  </test-fixture>

  <script>
  /* global AmfLoader */
  suite('SE-11415', () => {
    [
      ['Full model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let element;
        let amf;
        suiteSetup(() => {
          return AmfLoader.load(item[1], 'SE-11415')
          .then((data) => {
            amf = data;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
        });

        test('declares is undefined', () => {
          assert.isUndefined(element.declares);
        });

        test('references is computed', () => {
          assert.typeOf(element.references, 'array');
          assert.lengthOf(element.references, 9);
        });

        function getSecurity(element, references) {
          for (let i = 0, len = references.length; i < len; i++) {
            if (!element._hasType(references[i], element.ns.raml.vocabularies.document + 'Module')) {
              continue;
            }
            const declares = element._computeDeclares(references[i]);
            if (!declares) {
              continue;
            }
            for (let j = 0; j < declares.length; j++) {
              let item = declares[j];
              if (item instanceof Array) {
                item = item[0];
              }
              if (element._hasType(item, element.ns.raml.vocabularies.security + 'SecurityScheme')) {
                return item;
              }
            }
          }
        }

        test('Computes security from fragment', () => {
          const sec = getSecurity(element, element.references);
          const id = sec['@id'];
          const result = element._computeSecurityModel(undefined, element.references, id);
          assert.typeOf(result, 'object');
        });
      });
    });
  });
  </script>
</body>

</html>
