<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>api-documentation test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>

  <script src="../../../jsonlint/lib/jsonlint.js"></script>
  <script src="../../../codemirror/lib/codemirror.js"></script>
  <script src="../../../codemirror/addon/mode/loadmode.js"></script>
  <script src="../../../codemirror/mode/meta.js"></script>
  <script src="../../../codemirror/mode/javascript/javascript.js"></script>
  <script src="../../../codemirror/mode/xml/xml.js"></script>
  <script src="../../../codemirror/mode/htmlmixed/htmlmixed.js"></script>
  <script src="../../../codemirror/addon/lint/lint.js"></script>
  <script src="../../../codemirror/addon/lint/json-lint.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/headers-addon.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/show-hint.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/hint-http-headers.js"></script>
  <script>
  /* global CodeMirror */
  CodeMirror.modeURL = '../../../codemirror/mode/%N/%N.js';
  </script>
  <script src="../../../cryptojslib/components/core.js"></script>
  <script src="../../../cryptojslib/rollups/sha1.js"></script>
  <script src="../../../cryptojslib/components/enc-base64-min.js"></script>
  <script src="../../../cryptojslib/rollups/md5.js"></script>
  <script src="../../../cryptojslib/rollups/hmac-sha1.js"></script>
  <script src="../../../jsrsasign/lib/jsrsasign-rsa-min.js"></script>

</head>

<body>
  <test-fixture id="Basic">
    <template>
      <api-documentation></api-documentation>
    </template>
  </test-fixture>

  <test-fixture id="Aware">
    <template>
      <api-documentation aware="test"></api-documentation>
    </template>
  </test-fixture>

  <test-fixture id="InlineMethods">
    <template>
      <api-documentation inline-methods></api-documentation>
    </template>
  </test-fixture>

  <script type="module">
  import '../api-documentation.js';
  import sinon from '../../../sinon/pkg/sinon-esm.js';
  import {AmfLoader} from './amf-loader.js';
  import {afterNextRender} from '../../../@polymer/polymer/lib/utils/render-status.js';

  suite('Basic', () => {
    test('Adds raml-aware to the DOM if aware is set', (done) => {
      const element = fixture('Aware');
      flush(() => {
        const node = element.shadowRoot.querySelector('raml-aware');
        assert.ok(node);
        done();
      });
    });
    test('raml-aware is not in the DOM by default', (done) => {
      const element = fixture('Basic');
      flush(() => {
        const node = element.shadowRoot.querySelector('raml-aware');
        assert.notOk(node);
        done();
      });
    });

    function testNotPresent(item) {
      test(item + ' is not in the DOM', (done) => {
        const element = fixture('Basic');
        flush(() => {
          const node = element.shadowRoot.querySelector(item);
          assert.notOk(node);
          done();
        });
      });
    }

    [
      'api-summary',
      'api-endpoint-documentation',
      'api-method-documentation',
      'api-documentation-document',
      'api-type-documentation',
      'api-security-documentation'
    ].forEach((item) => testNotPresent(item));
  });

  suite('Full AMF model', () => {
    // let element;
    let amf;
    suiteSetup(() => {
      return AmfLoader.load()
      .then((data) => {
        amf = data[0];
      });
    });

    suite('Computations', () => {
      // suiteSetup((done) => {
      //   element = fixture('Basic');
      //   element.amfModel = amf;
      //   flush(() => done());
      // });

      function testVarState(item) {
        test(item[0] + ' is ' + String(item[1] + ' for type ' + item[2]), (done) => {
          const element = fixture('Basic');
          element.amfModel = amf;
          element.selectedType = item[2];
          element.selected = 'test';
          afterNextRender(element, () => {
            assert.equal(element[item[0]], item[1]);
            done();
          });
        });
      }

      [
        ['isEndpoint', false, 'summary'],
        ['isMethod', false, 'summary'],
        ['isDoc', false, 'summary'],
        ['isType', false, 'summary'],
        ['isSecurity', false, 'summary'],
        ['isSummary', true, 'summary'],

        ['isEndpoint', true, 'endpoint'],
        ['isMethod', false, 'endpoint'],
        ['isDoc', false, 'endpoint'],
        ['isType', false, 'endpoint'],
        ['isSecurity', false, 'endpoint'],
        ['isSummary', false, 'endpoint'],

        ['isEndpoint', false, 'method'],
        ['isMethod', true, 'method'],
        ['isDoc', false, 'method'],
        ['isType', false, 'method'],
        ['isSecurity', false, 'method'],
        ['isSummary', false, 'method'],

        ['isEndpoint', false, 'documentation'],
        ['isMethod', false, 'documentation'],
        ['isDoc', true, 'documentation'],
        ['isType', false, 'documentation'],
        ['isSecurity', false, 'documentation'],
        ['isSummary', false, 'documentation'],

        ['isEndpoint', false, 'type'],
        ['isMethod', false, 'type'],
        ['isDoc', false, 'type'],
        ['isType', true, 'type'],
        ['isSecurity', false, 'type'],
        ['isSummary', false, 'type'],

        ['isEndpoint', false, 'security'],
        ['isMethod', false, 'security'],
        ['isDoc', false, 'security'],
        ['isType', false, 'security'],
        ['isSecurity', true, 'security'],
        ['isSummary', false, 'security'],
      ].forEach((item) => testVarState(item));
    });

    suite('DOM content', () => {
      function testPresent(item) {
        test(item[0] + ' is in the DOM', (done) => {
          const element = fixture('Basic');
          element.amfModel = amf;
          element.selectedType = item[1];
          element.selected = 'test';
          afterNextRender(element, () => {
            flush(() => {
              const node = element.shadowRoot.querySelector(item[0]);
              assert.ok(node);
              done();
            });
          });
        });
      }

      [
        ['api-summary', 'summary'],
        ['api-endpoint-documentation', 'endpoint'],
        ['api-method-documentation', 'method'],
        ['api-documentation-document', 'documentation'],
        ['api-type-documentation', 'type'],
        ['api-security-documentation', 'security']
      ].forEach((item) => testPresent(item));
    });
  });

  suite('_apiModelChanged()', () => {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let amf;
        let element;
        suiteSetup(() => {
          return AmfLoader.load(item[1])
          .then((data) => {
            amf = data;
          });
        });

        setup(() => {
          element = fixture('Basic');
        });

        test('Calls _apiModelChanged() when amfModel is set', () => {
          const spy = sinon.spy(element, '_apiModelChanged');
          element.amfModel = amf;
          assert.isTrue(spy.called);
        });

        test('Calls _apiModelChanged() when selected is set', () => {
          const spy = sinon.spy(element, '_apiModelChanged');
          element.selected = 'test';
          assert.isTrue(spy.called);
        });

        test('Calls _apiModelChanged() when selectedType is set', () => {
          const spy = sinon.spy(element, '_apiModelChanged');
          element.selectedType = 'summary';
          assert.isTrue(spy.called);
        });

        test('Calls _apiModelChanged() when inlineMethods is set', () => {
          const spy = sinon.spy(element, '_apiModelChanged');
          element.inlineMethods = true;
          assert.isTrue(spy.called);
        });

        test('Sets __modelChangeDebouncer', () => {
          element.inlineMethods = true;
          assert.isTrue(element.__modelChangeDebouncer);
        });

        test('Eventually resets __modelChangeDebouncer', (done) => {
          element.inlineMethods = true;
          afterNextRender(element, () => {
            assert.isFalse(element.__modelChangeDebouncer);
            done();
          });
        });

        test('Eventually calls __processModel()', (done) => {
          const spy = sinon.spy(element, '__processModel');
          element.inlineMethods = true;
          afterNextRender(element, () => {
            assert.isTrue(spy.called);
            done();
          });
        });
      });
    });
  });

  suite('__processModel() API model', () => {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let amf;
        let element;
        suiteSetup(() => {
          return AmfLoader.load(item[1])
          .then((data) => {
            amf = data;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
        });

        test('Calls __processApiSpecSelection() (model as array)', () => {
          const spy = sinon.spy(element, '__processApiSpecSelection');
          element.__processModel(amf, 'test-selected', 'summary', true);
          assert.isTrue(spy.called, 'Function is called');
          assert.typeOf(spy.args[0][0], 'object', 'Model is set');
          assert.equal(spy.args[0][1], 'test-selected', 'Selected is set');
          assert.equal(spy.args[0][2], 'summary', 'Type is set');
          assert.isTrue(spy.args[0][3], 'Inline is set');
        });

        test('Calls __processApiSpecSelection() (model as object)', () => {
          const spy = sinon.spy(element, '__processApiSpecSelection');
          element.__processModel(amf[0], 'test-selected', 'summary', true);
          assert.isTrue(spy.called, 'Function is called');
          assert.typeOf(spy.args[0][0], 'object', 'Model is set');
          assert.equal(spy.args[0][1], 'test-selected', 'Selected is set');
          assert.equal(spy.args[0][2], 'summary', 'Type is set');
          assert.isTrue(spy.args[0][3], 'Inline is set');
        });
      });
    });
  });

  suite('__processModel() Library', () => {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let amf;
        let element;
        suiteSetup(() => {
          return AmfLoader.load(item[1], 'lib-fragment')
          .then((data) => {
            amf = data;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
        });

        test('Calls __processLibrarySelection()', () => {
          const spy = sinon.spy(element, '__processLibrarySelection');
          element.__processModel(amf, 'test-selected', 'summary');
          assert.isTrue(spy.called, 'Function is called');
          assert.typeOf(spy.args[0][0], 'object', 'Model is set');
          assert.equal(spy.args[0][1], 'test-selected', 'Selected is set');
          assert.equal(spy.args[0][2], 'summary', 'Type is set');
        });
      });
    });
  });

  suite('__processModel() Security fragment', () => {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let amf;
        let element;
        suiteSetup(() => {
          return AmfLoader.load(item[1], 'oauth2-fragment')
          .then((data) => {
            amf = data;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
        });

        test('Calls _processSecurityFragment()', () => {
          const spy = sinon.spy(element, '_processSecurityFragment');
          element.__processModel(amf);
          assert.isTrue(spy.called, 'Function is called');
          assert.typeOf(spy.args[0][0], 'object', 'Model is set');
        });
      });
    });
  });

  suite('__processModel() Documentation fragment', () => {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let amf;
        let element;
        suiteSetup(() => {
          return AmfLoader.load(item[1], 'documentation-fragment')
          .then((data) => {
            amf = data;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
        });

        test('Calls _processDocumentationFragment()', () => {
          const spy = sinon.spy(element, '_processDocumentationFragment');
          element.__processModel(amf);
          assert.isTrue(spy.called, 'Function is called');
          assert.typeOf(spy.args[0][0], 'object', 'Model is set');
        });
      });
    });
  });

  suite('__processModel() Type fragment', () => {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let amf;
        let element;
        suiteSetup(() => {
          return AmfLoader.load(item[1], 'type-fragment')
          .then((data) => {
            amf = data;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
        });

        test('Calls _processTypeFragment()', () => {
          const spy = sinon.spy(element, '_processTypeFragment');
          element.__processModel(amf);
          assert.isTrue(spy.called, 'Function is called');
          assert.typeOf(spy.args[0][0], 'object', 'Model is set');
        });
      });
    });
  });

  suite('__processModel() Documentation partial model', () => {
    let amf;
    let element;
    suiteSetup(() => {
      return AmfLoader.load(false, 'partial-model/documentation')
      .then((data) => {
        amf = data;
      });
    });

    setup(() => {
      element = fixture('Basic');
      element.amfModel = amf;
    });

    test('Calls _processDocumentationParial()', () => {
      const spy = sinon.spy(element, '_processDocumentationParial');
      element.__processModel(amf);
      assert.isTrue(spy.called, 'Function is called');
      assert.typeOf(spy.args[0][0], 'object', 'Model is set');
    });
  });

  suite('__processModel() Security partial model', () => {
    let amf;
    let element;
    suiteSetup(() => {
      return AmfLoader.load(false, 'partial-model/security')
      .then((data) => {
        amf = data;
      });
    });

    setup(() => {
      element = fixture('Basic');
      element.amfModel = amf;
    });

    test('Calls _processSecurityParial()', () => {
      const spy = sinon.spy(element, '_processSecurityParial');
      element.__processModel(amf);
      assert.isTrue(spy.called, 'Function is called');
      assert.typeOf(spy.args[0][0], 'object', 'Model is set');
    });
  });

  suite('__processModel() Security partial model', () => {
    let amf;
    let element;
    suiteSetup(() => {
      return AmfLoader.load(false, 'partial-model/type')
      .then((data) => {
        amf = data;
      });
    });

    setup(() => {
      element = fixture('Basic');
      element.amfModel = amf;
    });

    test('Calls _processTypeParial()', () => {
      const spy = sinon.spy(element, '_processTypeParial');
      element.__processModel(amf);
      assert.isTrue(spy.called, 'Function is called');
      assert.typeOf(spy.args[0][0], 'object', 'Model is set');
    });
  });

  suite('__processModel() Endpoint partial model', () => {
    let amf;
    let element;
    suiteSetup(() => {
      return AmfLoader.load(false, 'partial-model/endpoint')
      .then((data) => {
        amf = data;
      });
    });

    setup(() => {
      element = fixture('Basic');
      element.amfModel = amf;
    });

    test('Calls _processEndpointParial()', () => {
      const spy = sinon.spy(element, '_processEndpointParial');
      element.__processModel(amf, 'test-selected', 'endpoint', true);

      assert.isTrue(spy.called, 'Function is called');
      assert.typeOf(spy.args[0][0], 'object', 'Model is set');
      assert.equal(spy.args[0][1], 'test-selected', 'Selected is set');
      assert.equal(spy.args[0][2], 'endpoint', 'Type is set');
      assert.isTrue(spy.args[0][3], 'Inline is set');
    });
  });

  suite('__processModel() Unknown model', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Does nothing when no argument', () => {
      element.__processModel();
      // no error + coverage
    });

    test('Throws error for unknown model', () => {
      assert.throws(() => {
        element.__processModel({
          '@id': 'test'
        });
      });
    });
  });

  suite('__resetComponentSelection()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    [
      ['isEndpoint', 'endpoint', '_setIsEndpoint'],
      ['isMethod', 'method', '_setIsMethod'],
      ['isDoc', 'documentation', '_setIsDoc'],
      ['isType', 'type', '_setIsType'],
      ['isSecurity', 'security', '_setIsSecurity'],
      ['isSummary', 'summary', '_setIsSummary']
    ].forEach((item) => {
      test(`Sets ${item[0]} proeprty`, () => {
        element.__resetComponentSelection(item[1]);
        assert.isTrue(element[item[0]]);
      });

      test(`Ignores ${item[1]} value when already set`, () => {
        element[item[2]](true);
        const spy = sinon.spy(element, item[2]);
        element.__resetComponentSelection(item[1]);
        assert.isFalse(spy.called);
      });

      test(`Set opposite value for ${item[0]}`, () => {
        element[item[2]](false);
        element.__resetComponentSelection(item[1]);
        assert.isTrue(element[item[0]]);
      });
    });
  });

  suite('_isTypeFragment()', () => {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let typeModel;
        let docModel;
        let element;
        suiteSetup(() => {
          return Promise.all([
            AmfLoader.load(item[1], 'type-fragment'),
            AmfLoader.load(item[1], 'documentation-fragment')
          ])
          .then(([type, doc]) => {
            typeModel = type;
            docModel = doc;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = typeModel;
        });

        test('Returns true for type fragment (array)', () => {
          const model = typeModel instanceof Array ? typeModel : [typeModel];
          const result = element._isTypeFragment(model);
          assert.isTrue(result);
        });

        test('Returns true for type fragment (object)', () => {
          const model = typeModel instanceof Array ? typeModel[0] : typeModel;
          const result = element._isTypeFragment(model);
          assert.isTrue(result);
        });

        test('Returns false for other fragments', () => {
          const result = element._isTypeFragment(docModel);
          assert.isFalse(result);
        });
      });
    });
  });

  suite('_isSecurityFragment()', () => {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let securityModel;
        let docModel;
        let element;
        suiteSetup(() => {
          return Promise.all([
            AmfLoader.load(item[1], 'oauth2-fragment'),
            AmfLoader.load(item[1], 'documentation-fragment')
          ])
          .then(([type, doc]) => {
            securityModel = type;
            docModel = doc;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = securityModel;
        });

        test('Returns true for security fragment (array)', () => {
          const model = securityModel instanceof Array ? securityModel : [securityModel];
          const result = element._isSecurityFragment(model);
          assert.isTrue(result);
        });

        test('Returns true for security fragment (object)', () => {
          const model = securityModel instanceof Array ? securityModel[0] : securityModel;
          const result = element._isSecurityFragment(model);
          assert.isTrue(result);
        });

        test('Returns false for other fragments', () => {
          const result = element._isSecurityFragment(docModel);
          assert.isFalse(result);
        });
      });
    });
  });

  suite('_isDocumentationFragment()', () => {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let fragmentModel;
        let otherModel;
        let element;
        suiteSetup(() => {
          return Promise.all([
            AmfLoader.load(item[1], 'oauth2-fragment'),
            AmfLoader.load(item[1], 'documentation-fragment')
          ])
          .then(([other, fragment]) => {
            fragmentModel = fragment;
            otherModel = other;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = fragmentModel;
        });

        test('Returns true for documentation fragment (array)', () => {
          const model = fragmentModel instanceof Array ? fragmentModel : [fragmentModel];
          const result = element._isDocumentationFragment(model);
          assert.isTrue(result);
        });

        test('Returns true for documentation fragment (object)', () => {
          const model = fragmentModel instanceof Array ? fragmentModel[0] : fragmentModel;
          const result = element._isDocumentationFragment(model);
          assert.isTrue(result);
        });

        test('Returns false for other fragments', () => {
          const result = element._isDocumentationFragment(otherModel);
          assert.isFalse(result);
        });
      });
    });
  });

  suite('_isTypePartialModel()', () => {
    let partialModel;
    let otherModel;
    let element;
    suiteSetup(() => {
      return Promise.all([
        AmfLoader.load(false, 'partial-model/type'),
        AmfLoader.load(false, 'partial-model/documentation')
      ])
      .then(([model, other]) => {
        partialModel = model;
        otherModel = other;
      });
    });

    setup(() => {
      element = fixture('Basic');
      element.amfModel = partialModel;
    });

    test('Returns true for type model (array)', () => {
      const model = partialModel instanceof Array ? partialModel : [partialModel];
      const result = element._isTypePartialModel(model);
      assert.isTrue(result);
    });

    test('Returns true for type model (object)', () => {
      const model = partialModel instanceof Array ? partialModel[0] : partialModel;
      const result = element._isTypePartialModel(model);
      assert.isTrue(result);
    });

    test('Returns false for other models', () => {
      const result = element._isTypePartialModel(otherModel);
      assert.isFalse(result);
    });
  });

  suite('_isSecurityPartialModel()', () => {
    let partialModel;
    let otherModel;
    let element;
    suiteSetup(() => {
      return Promise.all([
        AmfLoader.load(false, 'partial-model/security'),
        AmfLoader.load(false, 'partial-model/documentation')
      ])
      .then(([model, other]) => {
        partialModel = model;
        otherModel = other;
      });
    });

    setup(() => {
      element = fixture('Basic');
      element.amfModel = partialModel;
    });

    test('Returns true for security model (array)', () => {
      const model = partialModel instanceof Array ? partialModel : [partialModel];
      const result = element._isSecurityPartialModel(model);
      assert.isTrue(result);
    });

    test('Returns true for security model (object)', () => {
      const model = partialModel instanceof Array ? partialModel[0] : partialModel;
      const result = element._isSecurityPartialModel(model);
      assert.isTrue(result);
    });

    test('Returns false for other models', () => {
      const result = element._isSecurityPartialModel(otherModel);
      assert.isFalse(result);
    });
  });

  suite('_isDocumentationPartialModel()', () => {
    let partialModel;
    let otherModel;
    let element;
    suiteSetup(() => {
      return Promise.all([
        AmfLoader.load(false, 'partial-model/documentation'),
        AmfLoader.load(false, 'partial-model/security')
      ])
      .then(([model, other]) => {
        partialModel = model;
        otherModel = other;
      });
    });

    setup(() => {
      element = fixture('Basic');
      element.amfModel = partialModel;
    });

    test('Returns true for documentation model (array)', () => {
      const model = partialModel instanceof Array ? partialModel : [partialModel];
      const result = element._isDocumentationPartialModel(model);
      assert.isTrue(result);
    });

    test('Returns true for documentation model (object)', () => {
      const model = partialModel instanceof Array ? partialModel[0] : partialModel;
      const result = element._isDocumentationPartialModel(model);
      assert.isTrue(result);
    });

    test('Returns false for other models', () => {
      const result = element._isDocumentationPartialModel(otherModel);
      assert.isFalse(result);
    });
  });

  suite('_isEndpointPartialModel()', () => {
    let partialModel;
    let otherModel;
    let element;
    suiteSetup(() => {
      return Promise.all([
        AmfLoader.load(false, 'partial-model/endpoint'),
        AmfLoader.load(false, 'partial-model/security')
      ])
      .then(([model, other]) => {
        partialModel = model;
        otherModel = other;
      });
    });

    setup(() => {
      element = fixture('Basic');
      element.amfModel = partialModel;
    });

    test('Returns true for endpoint model (array)', () => {
      const model = partialModel instanceof Array ? partialModel : [partialModel];
      const result = element._isEndpointPartialModel(model);
      assert.isTrue(result);
    });

    test('Returns true for endpoint model (object)', () => {
      const model = partialModel instanceof Array ? partialModel[0] : partialModel;
      const result = element._isEndpointPartialModel(model);
      assert.isTrue(result);
    });

    test('Returns false for other models', () => {
      const result = element._isEndpointPartialModel(otherModel);
      assert.isFalse(result);
    });
  });

  function getSecurityScheme(element, model, name) {
    const declares = element._computeDeclares(model);
    for (let i = 0; i < declares.length; i++) {
      const item = declares[i];
      if (element._hasType(item, element.ns.raml.vocabularies.security + 'SecurityScheme')) {
        const value = element._getValue(item, element.ns.raml.vocabularies.security + 'name');
        if (value === name) {
          return item;
        }
      }
    }
    const references = element._computeReferences(model);
    if (references) {
      for (let i = 0, len = references.length; i < len; i++) {
        if (!element._hasType(references[i], element.ns.raml.vocabularies.document + 'Module')) {
          continue;
        }
        const declares = element._computeDeclares(references[i]);
        for (let j = 0; j < declares.length; j++) {
          const item = declares[i];
          if (element._hasType(item, element.ns.raml.vocabularies.security + 'SecurityScheme')) {
            const value = element._getValue(item, element.ns.raml.vocabularies.security + 'name');
            if (value === name) {
              return item;
            }
          }
        }
      }
    }
  }

  function getSecurityByReference(element, model, name) {
    const references = element._computeReferences(model);
    if (references) {
      for (let i = 0, len = references.length; i < len; i++) {
        if (!element._hasType(references[i], element.ns.raml.vocabularies.document + 'Module')) {
          continue;
        }
        const value = getSecurityScheme(element, references[i], name);
        if (value) {
          return value;
        }
      }
    }
  }

  suite('_computeDeclById()', () => {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let amfModel;
        let element;
        suiteSetup(() => {
          return AmfLoader.load(item[1], 'lib-fragment')
          .then((model) => {
            amfModel = model;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = amfModel;
        });

        test('Returns computed value', () => {
          const scheme = getSecurityScheme(element, amfModel, 'OAuth1');
          const result = element._computeDeclById(amfModel, scheme['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result['@id'], scheme['@id']);
        });

        test('Returns undefined for unknown', () => {
          const result = element._computeDeclById(amfModel, 'unknown');
          assert.isUndefined(result);
        });

        test('Returns undefined when no declares', () => {
          const result = element._computeDeclById({}, 'unknown');
          assert.isUndefined(result);
        });
      });
    });
  });

  suite('_computeSecurityApiModel()', () => {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let amfModel;
        let element;
        suiteSetup(() => {
          return AmfLoader.load(item[1])
          .then((model) => {
            amfModel = model;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = amfModel;
        });

        test('Returns scheme from declares', () => {
          const scheme = getSecurityScheme(element, amfModel, 'oauth_2_0');
          const result = element._computeSecurityApiModel(amfModel, scheme['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result['@id'], scheme['@id']);
        });

        test('Returns scheme from references', () => {
          const scheme = getSecurityByReference(element, amfModel, 'oauthLib');
          const result = element._computeSecurityApiModel(amfModel, scheme['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result['@id'], scheme['@id']);
        });

        test('Returns undefined when selection not found', () => {
          const result = element._computeSecurityApiModel(amfModel, 'unknown');
          assert.isUndefined(result);
        });

        test('Returns undefined model has no declares / references', () => {
          const result = element._computeSecurityApiModel({}, 'unknown');
          assert.isUndefined(result);
        });
      });
    });
  });

  suite('_isLibrary()', () => {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let fragmentModel;
        let otherModel;
        let element;
        suiteSetup(() => {
          return Promise.all([
            AmfLoader.load(item[1], 'lib-fragment'),
            AmfLoader.load(item[1], 'oauth2-fragment')
          ])
          .then(([fragment, other]) => {
            fragmentModel = fragment;
            otherModel = other;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = fragmentModel;
        });

        test('Returns true for a library', () => {
          const result = element._isLibrary(fragmentModel);
          assert.isTrue(result);
        });

        test('Returns false for other fragments', () => {
          const result = element._isLibrary(otherModel);
          assert.isFalse(result);
        });

        test('Returns false when no argument', () => {
          const result = element._isLibrary();
          assert.isFalse(result);
        });
      });
    });
  });

  suite('_renderMethod()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Returns true when method type and not inline', () => {
      const result = element._renderMethod(false, true);
      assert.isTrue(result);
    });

    test('Returns false when method type and inline', () => {
      const result = element._renderMethod(true, true);
      assert.isFalse(result);
    });

    test('Returns false when not method method type and inline', () => {
      const result = element._renderMethod(true, false);
      assert.isFalse(result);
    });

    test('Returns false when not method method type and not inline', () => {
      const result = element._renderMethod(false, false);
      assert.isFalse(result);
    });

    test('Returns false when arguments are missing', () => {
      const result = element._renderMethod();
      assert.isFalse(result);
    });
  });

  suite('_renderEndpoint()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Returns true when endpoint type and not inline', () => {
      const result = element._renderEndpoint(false, true);
      assert.isTrue(result);
    });

    test('Returns false when endpoint type and inline', () => {
      const result = element._renderEndpoint(true, true);
      assert.isFalse(result);
    });

    test('Returns false when not endpoint method type and inline', () => {
      const result = element._renderEndpoint(true, false);
      assert.isFalse(result);
    });

    test('Returns false when not endpoint method type and not inline', () => {
      const result = element._renderEndpoint(false, false);
      assert.isFalse(result);
    });

    test('Returns false when arguments are missing', () => {
      const result = element._renderEndpoint();
      assert.isFalse(result);
    });
  });

  suite('_renderInlineEndpoint()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Returns false when not inline', () => {
      const result = element._renderInlineEndpoint(false, true, true);
      assert.isFalse(result);
    });

    test('Returns true when endpoint and method', () => {
      const result = element._renderInlineEndpoint(true, true, true);
      assert.isTrue(result);
    });

    test('Returns true when endpoint', () => {
      const result = element._renderInlineEndpoint(true, false, true);
      assert.isTrue(result);
    });

    test('Returns true when method', () => {
      const result = element._renderInlineEndpoint(true, true, false);
      assert.isTrue(result);
    });

    test('Returns false when otherwise', () => {
      const result = element._renderInlineEndpoint(true, false, false);
      assert.isFalse(result);
    });
  });

  suite('_computeMethodPartialEndpoint()', () => {
    let amf;
    let element;
    suiteSetup(() => {
      return AmfLoader.load(false, 'partial-model/endpoint')
      .then((data) => {
        amf = data;
      });
    });

    setup(() => {
      element = fixture('Basic');
      element.amfModel = amf;
    });

    test('Returns operation model', () => {
      const result = element._computeMethodPartialEndpoint(amf, '#138');
      assert.equal(result['@id'], '#138');
    });

    test('Returns undefined when not found', () => {
      const result = element._computeMethodPartialEndpoint(amf, 'unknown');
      assert.isUndefined(result);
    });

    test('Returns undefined when no operations', () => {
      const result = element._computeMethodPartialEndpoint({}, '#138');
      assert.isUndefined(result);
    });
  });

  suite('_computeMethodNext()', function() {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let endpoints;
        let element;
        let webApi;
        let apiModel;
        let endpointModel;

        suiteSetup(() => {
          return Promise.all([
            AmfLoader.load(item[1]),
            AmfLoader.load(false, 'partial-model/endpoint')
          ])
          .then(([api, endpoint]) => {
            apiModel = api;
            endpointModel = endpoint;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = apiModel;
          webApi = element._computeWebApi(apiModel);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeMethodNext(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link from API model', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodNext(apiModel, ops[0]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Create a person');
          assert.equal(result.id, ops[1]['@id']);
        });

        test('Does not compute next method link when last method', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodNext(apiModel, ops[2]['@id']);
          assert.isUndefined(result);
        });

        test('Computes next method link from Endpoint partial model', function() {
          element.amfModel = endpointModel;
          const result = element._computeMethodNext(endpointModel, '#138');
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Create a user');
          assert.equal(result.id, '#115');
        });
      });
    });
  });

  suite('_computeMethodPrevious()', function() {
    [
      ['Regular model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let endpoints;
        let element;
        let webApi;
        let apiModel;
        let endpointModel;

        suiteSetup(() => {
          return Promise.all([
            AmfLoader.load(item[1]),
            AmfLoader.load(false, 'partial-model/endpoint')
          ])
          .then(([api, endpoint]) => {
            apiModel = api;
            endpointModel = endpoint;
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = apiModel;
          webApi = element._computeWebApi(apiModel);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeMethodPrevious(apiModel, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link from API model', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodPrevious(apiModel, ops[1]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'List people');
          assert.equal(result.id, ops[0]['@id']);
        });

        test('Does not compute previous method link when first method', function() {
          const ops = element._computeOperations(webApi, endpoints[0]['@id']);
          const result = element._computeMethodPrevious(apiModel, ops[0]['@id']);
          assert.isUndefined(result);
        });

        test('Computes previous method link from Endpoint partial model', function() {
          element.amfModel = endpointModel;
          const result = element._computeMethodPrevious(endpointModel, '#115');
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Update a user');
          assert.equal(result.id, '#138');
        });
      });
    });
  });

  // suite('Data computation', () => {
  //   suite('Regular model', () => {
  //     let amf;
  //     suiteSetup(() => {
  //       return AmfLoader.load()
  //       .then((data) => {
  //         amf = data;
  //       });
  //     });
  //
  //     suite('_computeEndpointNext()', function() {
  //       let endpoints;
  //       let element;
  //       let webApi;
  //       setup(() => {
  //         element = fixture('Basic');
  //         element.amfModel = amf;
  //         webApi = element._computeWebApi(amf);
  //         endpoints = element._computeEndpoints(webApi);
  //       });
  //
  //       test('Returns undefined when no selected', function() {
  //         const result = element._computeEndpointNext(amf, 'nothing');
  //         assert.isUndefined(result);
  //       });
  //
  //       test('Computes next method link', function() {
  //         const result = element._computeEndpointNext(amf, endpoints[3]['@id']);
  //         assert.typeOf(result, 'object');
  //         assert.equal(result.label, 'Products');
  //         assert.equal(result.id, endpoints[4]['@id']);
  //       });
  //
  //       test('Does not compute next method link when last method', function() {
  //         const result = element._computeEndpointNext(amf, endpoints[12]['@id']);
  //         assert.isUndefined(result);
  //       });
  //     });
  //
  //     suite('_computeEndpointPrevious()', function() {
  //       let endpoints;
  //       let element;
  //       let webApi;
  //       setup(() => {
  //         element = fixture('Basic');
  //         element.amfModel = amf;
  //         webApi = element._computeWebApi(amf);
  //         endpoints = element._computeEndpoints(webApi);
  //       });
  //
  //       test('Returns undefined when no selected', function() {
  //         const result = element._computeEndpointPrevious(amf, 'nothing');
  //         assert.isUndefined(result);
  //       });
  //
  //       test('Computes next method link', function() {
  //         const result = element._computeEndpointPrevious(amf, endpoints[5]['@id']);
  //         assert.typeOf(result, 'object');
  //         assert.equal(result.label, 'Products');
  //         assert.equal(result.id, endpoints[4]['@id']);
  //       });
  //
  //       test('Does not compute next method link when last method', function() {
  //         const result = element._computeEndpointPrevious(amf, endpoints[0]['@id']);
  //         assert.isUndefined(result);
  //       });
  //     });
  //   });
  suite('handleNavigationEvents property', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Calls _registerNavigationEvents() when state is set', () => {
      const spy = sinon.spy(element, '_registerNavigationEvents');
      element.handleNavigationEvents = true;
      assert.isTrue(spy.called);
    });

    test('Sets __eventsRegistered flag', () => {
      element.handleNavigationEvents = true;
      assert.isTrue(element.__eventsRegistered);
    });

    test('Calls _unregisterNavigationEvents() when state is set', () => {
      element.handleNavigationEvents = true;
      const spy = sinon.spy(element, '_unregisterNavigationEvents');
      element.handleNavigationEvents = false;
      assert.isTrue(spy.called);
    });

    test('Sets __eventsRegistered flag', () => {
      element.handleNavigationEvents = true;
      element.handleNavigationEvents = false;
      assert.isFalse(element.__eventsRegistered);
    });

    test('Updates selection from the event', () => {
      element.handleNavigationEvents = true;
      document.body.dispatchEvent(new CustomEvent('api-navigation-selection-changed', {
        bubbles: true,
        detail: {
          selected: 'summary',
          type: 'summary'
        }
      }));
      assert.equal(element.selected, 'summary');
      assert.equal(element.selectedType, 'summary');
    });

    test('Ignores passive events', () => {
      element.handleNavigationEvents = true;
      document.body.dispatchEvent(new CustomEvent('api-navigation-selection-changed', {
        bubbles: true,
        detail: {
          selected: 'summary',
          type: 'summary',
          passive: true
        }
      }));
      assert.isUndefined(element.selected);
      assert.isUndefined(element.selectedType);
    });
  });
  //
  // suite('Security scheme rendering', () => {
  //   function getScheme(element, name) {
  //     const declares = element._computeDeclares(element.amfModel);
  //     for (let i = 0; i < declares.length; i++) {
  //       const item = declares[i];
  //       if (element._hasType(item, element.ns.raml.vocabularies.security + 'SecurityScheme')) {
  //         const value = element._getValue(item, element.ns.raml.vocabularies.security + 'name');
  //         if (value === name) {
  //           return item;
  //         }
  //       }
  //     }
  //   }
  //   [
  //     ['Full model', false],
  //     ['Compact model', true]
  //   ].forEach((item) => {
  //     suite(item[0], () => {
  //       let element;
  //       setup(() => {
  //         element = fixture('Basic');
  //         return AmfLoader.load(item[1])
  //         .then((data) => {
  //           element.amfModel = data;
  //         });
  //       });
  //
  //       test('Renders security scheme', (done) => {
  //         const scheme = getScheme(element, 'oauth_2_0');
  //         const id = scheme['@id'];
  //         element.selected = id;
  //         element.selectedType = 'security';
  //         flush(() => {
  //           const node = element.shadowRoot.querySelector('api-security-documentation');
  //           assert.ok(node);
  //           done();
  //         });
  //       });
  //
  //       test('Scheme is computed and set on panel', (done) => {
  //         const scheme = getScheme(element, 'oauth_2_0');
  //         const id = scheme['@id'];
  //         element.selected = id;
  //         element.selectedType = 'security';
  //         flush(() => {
  //           const node = element.shadowRoot.querySelector('api-security-documentation');
  //           assert.typeOf(node.security, 'object');
  //           assert.isTrue(node.security === scheme);
  //           done();
  //         });
  //       });
  //     });
  //   });
  // });
  //
  // suite('RAML library rendering', () => {
  //   function getScheme(element, name) {
  //     const declares = element._computeDeclares(element.amfModel);
  //     for (let i = 0; i < declares.length; i++) {
  //       const item = declares[i];
  //       if (element._hasType(item, element.ns.raml.vocabularies.security + 'SecurityScheme')) {
  //         const value = element._getValue(item, element.ns.raml.vocabularies.security + 'name');
  //         if (value === name) {
  //           return item;
  //         }
  //       }
  //     }
  //   }
  //
  //   function getType(element, name) {
  //     const declares = element._computeDeclares(element.amfModel);
  //     for (let i = 0; i < declares.length; i++) {
  //       const item = declares[i];
  //       if (element._hasType(item, element.ns.w3.shacl.name + 'NodeShape')) {
  //         const value = element._getValue(item, element.ns.w3.shacl.name + 'name');
  //         if (value === name) {
  //           return item;
  //         }
  //       }
  //     }
  //   }
  //   [
  //     ['Full model', false],
  //     ['Compact model', true]
  //   ].forEach((item) => {
  //     suite(item[0], () => {
  //       let element;
  //       setup(() => {
  //         element = fixture('Basic');
  //         return AmfLoader.load(item[1], 'lib-fragment')
  //         .then((data) => {
  //           element.amfModel = data;
  //         });
  //       });
  //
  //       test('Renders security scheme from a library', (done) => {
  //         const scheme = getScheme(element, 'OAuth1');
  //         const id = scheme['@id'];
  //         element.selected = id;
  //         element.selectedType = 'security';
  //         flush(() => {
  //           const node = element.shadowRoot.querySelector('api-security-documentation');
  //           assert.ok(node);
  //           done();
  //         });
  //       });
  //
  //       test('Renders type from a library', (done) => {
  //         const scheme = getType(element, 'myType');
  //         const id = scheme['@id'];
  //         element.selected = id;
  //         element.selectedType = 'type';
  //         flush(() => {
  //           const node = element.shadowRoot.querySelector('api-type-documentation');
  //           assert.ok(node);
  //           done();
  //         });
  //       });
  //     });
  //   });
  // });
  </script>
</body>

</html>
