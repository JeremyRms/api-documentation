<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>api-documentation test</title>
  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="amf-loader.js"></script>
  <link rel="import" href="../../arc-polyfills/arc-polyfills.html">
  <link rel="import" href="../api-documentation.html">
</head>

<body>
  <test-fixture id="Basic">
    <template>
      <api-documentation></api-documentation>
    </template>
  </test-fixture>

  <test-fixture id="Aware">
    <template>
      <api-documentation aware="test"></api-documentation>
    </template>
  </test-fixture>

  <test-fixture id="InlineMethods">
    <template>
      <api-documentation inline-methods></api-documentation>
    </template>
  </test-fixture>
  <script>
  suite('Basic', () => {
    test('Adds raml-aware to the DOM if aware is set', (done) => {
      const element = fixture('Aware');
      flush(() => {
        const node = element.shadowRoot.querySelector('raml-aware');
        assert.ok(node);
        done();
      });
    });
    test('raml-aware is not in the DOM by default', (done) => {
      const element = fixture('Basic');
      flush(() => {
        const node = element.shadowRoot.querySelector('raml-aware');
        assert.notOk(node);
        done();
      });
    });

    function testNotPresent(item) {
      test(item + ' is not in the DOM', (done) => {
        const element = fixture('Basic');
        flush(() => {
          const node = element.shadowRoot.querySelector(item);
          assert.notOk(node);
          done();
        });
      });
    }

    [
      'api-summary',
      'api-endpoint-documentation',
      'api-method-documentation',
      'api-documentation-document',
      'api-type-documentation',
      'api-security-documentation'
    ].forEach((item) => testNotPresent(item));
  });

  /* global AmfLoader */
  suite('Full AMF model', () => {
    let element;
    let amf;
    suiteSetup(() => {
      return AmfLoader.load()
        .then((data) => {
          amf = data[0];
        });
    });
    suite('Computations', () => {
      suiteSetup((done) => {
        element = fixture('Basic');
        element.amfModel = amf;
        flush(() => done());
      });

      test('webApi is computed', () => {
        assert.typeOf(element.webApi, 'object');
      });

      test('declares is computed', () => {
        assert.typeOf(element.declares, 'array');
      });

      function testVarState(item) {
        test(item[0] + ' is ' + String(item[1] + ' for type ' + item[2]), () => {
          const element = fixture('Basic');
          element.amfModel = amf;
          element.selectedType = item[2];
          assert.equal(element[item[0]], item[1]);
        });
      }

      [
        ['isEndpoint', false, 'summary'],
        ['isMethod', false, 'summary'],
        ['isDoc', false, 'summary'],
        ['isType', false, 'summary'],
        ['isSecurity', false, 'summary'],
        ['isSummary', true, 'summary'],

        ['isEndpoint', true, 'endpoint'],
        ['isMethod', false, 'endpoint'],
        ['isDoc', false, 'endpoint'],
        ['isType', false, 'endpoint'],
        ['isSecurity', false, 'endpoint'],
        ['isSummary', false, 'endpoint'],

        ['isEndpoint', false, 'method'],
        ['isMethod', true, 'method'],
        ['isDoc', false, 'method'],
        ['isType', false, 'method'],
        ['isSecurity', false, 'method'],
        ['isSummary', false, 'method'],

        ['isEndpoint', false, 'documentation'],
        ['isMethod', false, 'documentation'],
        ['isDoc', true, 'documentation'],
        ['isType', false, 'documentation'],
        ['isSecurity', false, 'documentation'],
        ['isSummary', false, 'documentation'],

        ['isEndpoint', false, 'type'],
        ['isMethod', false, 'type'],
        ['isDoc', false, 'type'],
        ['isType', true, 'type'],
        ['isSecurity', false, 'type'],
        ['isSummary', false, 'type'],

        ['isEndpoint', false, 'security'],
        ['isMethod', false, 'security'],
        ['isDoc', false, 'security'],
        ['isType', false, 'security'],
        ['isSecurity', true, 'security'],
        ['isSummary', false, 'security'],
      ].forEach((item) => testVarState(item));

    });
    suite('DOM content', () => {
      function testPresent(item) {
        test(item[0] + ' is in the DOM', (done) => {
          const element = fixture('Basic');
          element.amfModel = amf;
          element.selectedType = item[1];
          flush(() => {
            const node = element.shadowRoot.querySelector(item[0]);
            assert.ok(node);
            done();
          });
        });
      }

      [
        ['api-summary', 'summary'],
        ['api-endpoint-documentation', 'endpoint'],
        ['api-method-documentation', 'method'],
        ['api-documentation-document', 'documentation'],
        ['api-type-documentation', 'type'],
        ['api-security-documentation', 'security']
      ].forEach((item) => testPresent(item));
    });
  });

  suite('Data computation', () => {
    suite('Regular model', () => {
      let amf;
      suiteSetup(() => {
        return AmfLoader.load()
        .then((data) => {
          amf = data;
        });
      });

      suite('_updateEndpoint()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Computes model for endpoint selection', () => {
          const endpoint = endpoints[0];
          element.selected = endpoint['@id'];
          element._setIsEndpoint(true);

          assert.typeOf(element.endpoint, 'object');
          assert.equal(element.endpoint['@id'], endpoint['@id']);
        });

        test('Computes model for method selection', () => {
          const endpoint = endpoints[0];
          const endpointId = endpoint['@id'];
          const ops = element._computeOperations(webApi, endpointId);
          element.selected = ops[0]['@id'];
          element._setIsMethod(true);

          assert.typeOf(element.endpoint, 'object');
          assert.equal(element.endpoint['@id'], endpoint['@id']);
        });
      });

      suite('_computeMethodNext()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeMethodNext(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodNext(webApi, ops[0]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Create a person');
          assert.equal(result.id, ops[1]['@id']);
        });

        test('Does not compute next method link when last method', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodNext(webApi, ops[2]['@id']);
          assert.isUndefined(result);
        });
      });

      suite('_computeMethodPrevious()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeMethodPrevious(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes previous method link', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodPrevious(webApi, ops[1]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'List people');
          assert.equal(result.id, ops[0]['@id']);
        });

        test('Does not compute previous method link when last method', function() {
          const ops = element._computeOperations(webApi, endpoints[0]['@id']);
          const result = element._computeMethodPrevious(webApi, ops[0]['@id']);
          assert.isUndefined(result);
        });
      });

      suite('_computeEndpointNext()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeEndpointNext(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link', function() {
          const result = element._computeEndpointNext(webApi, endpoints[3]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Products');
          assert.equal(result.id, endpoints[4]['@id']);
        });

        test('Does not compute next method link when last method', function() {
          const result = element._computeEndpointNext(webApi, endpoints[12]['@id']);
          assert.isUndefined(result);
        });
      });

      suite('_computeEndpointPrevious()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeEndpointPrevious(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link', function() {
          const result = element._computeEndpointPrevious(webApi, endpoints[5]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Products');
          assert.equal(result.id, endpoints[4]['@id']);
        });

        test('Does not compute next method link when last method', function() {
          const result = element._computeEndpointPrevious(webApi, endpoints[0]['@id']);
          assert.isUndefined(result);
        });
      });
    });

    suite('Compact model', () => {
      let amf;
      suiteSetup(() => {
        return AmfLoader.load(true)
        .then((data) => {
          amf = data;
        });
      });

      suite('_updateEndpoint()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Computes model for endpoint selection', () => {
          const endpoint = endpoints[0];
          element.selected = endpoint['@id'];
          element._setIsEndpoint(true);

          assert.typeOf(element.endpoint, 'object');
          assert.equal(element.endpoint['@id'], endpoint['@id']);
        });

        test('Computes model for method selection', () => {
          const endpoint = endpoints[0];
          const endpointId = endpoint['@id'];
          const ops = element._computeOperations(webApi, endpointId);
          element.selected = ops[0]['@id'];
          element._setIsMethod(true);

          assert.typeOf(element.endpoint, 'object');
          assert.equal(element.endpoint['@id'], endpoint['@id']);
        });
      });

      suite('_computeMethodNext()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeMethodNext(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodNext(webApi, ops[0]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Create a person');
          assert.equal(result.id, ops[1]['@id']);
        });

        test('Does not compute next method link when last method', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodNext(webApi, ops[2]['@id']);
          assert.isUndefined(result);
        });
      });

      suite('_computeMethodPrevious()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeMethodPrevious(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes previous method link', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodPrevious(webApi, ops[1]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'List people');
          assert.equal(result.id, ops[0]['@id']);
        });

        test('Does not compute previous method link when last method', function() {
          const ops = element._computeOperations(webApi, endpoints[0]['@id']);
          const result = element._computeMethodPrevious(webApi, ops[0]['@id']);
          assert.isUndefined(result);
        });
      });

      suite('_computeEndpointNext()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeEndpointNext(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link', function() {
          const result = element._computeEndpointNext(webApi, endpoints[3]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Products');
          assert.equal(result.id, endpoints[4]['@id']);
        });

        test('Does not compute next method link when last method', function() {
          const result = element._computeEndpointNext(webApi, endpoints[12]['@id']);
          assert.isUndefined(result);
        });
      });

      suite('_computeEndpointPrevious()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeEndpointPrevious(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link', function() {
          const result = element._computeEndpointPrevious(webApi, endpoints[5]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Products');
          assert.equal(result.id, endpoints[4]['@id']);
        });

        test('Does not compute next method link when last method', function() {
          const result = element._computeEndpointPrevious(webApi, endpoints[0]['@id']);
          assert.isUndefined(result);
        });
      });
    });
  });
  </script>
</body>

</html>
