<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>api-documentation test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>
  <script src="../../../sinon/pkg/sinon.js"></script>

  <script src="./amf-loader.js"></script>

  <script src="../../../jsonlint/lib/jsonlint.js"></script>
  <script src="../../../codemirror/lib/codemirror.js"></script>
  <script src="../../../codemirror/addon/mode/loadmode.js"></script>
  <script src="../../../codemirror/mode/meta.js"></script>
  <script src="../../../codemirror/mode/javascript/javascript.js"></script>
  <script src="../../../codemirror/mode/xml/xml.js"></script>
  <script src="../../../codemirror/mode/htmlmixed/htmlmixed.js"></script>
  <script src="../../../codemirror/addon/lint/lint.js"></script>
  <script src="../../../codemirror/addon/lint/json-lint.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/headers-addon.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/show-hint.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/hint-http-headers.js"></script>
  <script>
  /* global CodeMirror */
  CodeMirror.modeURL = '../../../codemirror/mode/%N/%N.js';
  </script>
  <script src="../../../cryptojslib/components/core.js"></script>
  <script src="../../../cryptojslib/rollups/sha1.js"></script>
  <script src="../../../cryptojslib/components/enc-base64-min.js"></script>
  <script src="../../../cryptojslib/rollups/md5.js"></script>
  <script src="../../../cryptojslib/rollups/hmac-sha1.js"></script>
  <script src="../../../jsrsasign/lib/jsrsasign-rsa-min.js"></script>
  
</head>

<body>
  <test-fixture id="Basic">
    <template>
      <api-documentation></api-documentation>
    </template>
  </test-fixture>

  <test-fixture id="Aware">
    <template>
      <api-documentation aware="test"></api-documentation>
    </template>
  </test-fixture>

  <test-fixture id="InlineMethods">
    <template>
      <api-documentation inline-methods></api-documentation>
    </template>
  </test-fixture>
  <script type="module">
  import '../api-documentation.js';
  suite('Basic', () => {
    test('Adds raml-aware to the DOM if aware is set', (done) => {
      const element = fixture('Aware');
      flush(() => {
        const node = element.shadowRoot.querySelector('raml-aware');
        assert.ok(node);
        done();
      });
    });
    test('raml-aware is not in the DOM by default', (done) => {
      const element = fixture('Basic');
      flush(() => {
        const node = element.shadowRoot.querySelector('raml-aware');
        assert.notOk(node);
        done();
      });
    });

    function testNotPresent(item) {
      test(item + ' is not in the DOM', (done) => {
        const element = fixture('Basic');
        flush(() => {
          const node = element.shadowRoot.querySelector(item);
          assert.notOk(node);
          done();
        });
      });
    }

    [
      'api-summary',
      'api-endpoint-documentation',
      'api-method-documentation',
      'api-documentation-document',
      'api-type-documentation',
      'api-security-documentation'
    ].forEach((item) => testNotPresent(item));
  });

  /* global AmfLoader */
  suite('Full AMF model', () => {
    let element;
    let amf;
    suiteSetup(() => {
      return AmfLoader.load()
        .then((data) => {
          amf = data[0];
        });
    });
    suite('Computations', () => {
      suiteSetup((done) => {
        element = fixture('Basic');
        element.amfModel = amf;
        flush(() => done());
      });

      test('webApi is computed', () => {
        assert.typeOf(element.webApi, 'object');
      });

      test('declares is computed', () => {
        assert.typeOf(element.declares, 'array');
      });

      function testVarState(item) {
        test(item[0] + ' is ' + String(item[1] + ' for type ' + item[2]), () => {
          const element = fixture('Basic');
          element.amfModel = amf;
          element.selectedType = item[2];
          assert.equal(element[item[0]], item[1]);
        });
      }

      [
        ['isEndpoint', false, 'summary'],
        ['isMethod', false, 'summary'],
        ['isDoc', false, 'summary'],
        ['isType', false, 'summary'],
        ['isSecurity', false, 'summary'],
        ['isSummary', true, 'summary'],

        ['isEndpoint', true, 'endpoint'],
        ['isMethod', false, 'endpoint'],
        ['isDoc', false, 'endpoint'],
        ['isType', false, 'endpoint'],
        ['isSecurity', false, 'endpoint'],
        ['isSummary', false, 'endpoint'],

        ['isEndpoint', false, 'method'],
        ['isMethod', true, 'method'],
        ['isDoc', false, 'method'],
        ['isType', false, 'method'],
        ['isSecurity', false, 'method'],
        ['isSummary', false, 'method'],

        ['isEndpoint', false, 'documentation'],
        ['isMethod', false, 'documentation'],
        ['isDoc', true, 'documentation'],
        ['isType', false, 'documentation'],
        ['isSecurity', false, 'documentation'],
        ['isSummary', false, 'documentation'],

        ['isEndpoint', false, 'type'],
        ['isMethod', false, 'type'],
        ['isDoc', false, 'type'],
        ['isType', true, 'type'],
        ['isSecurity', false, 'type'],
        ['isSummary', false, 'type'],

        ['isEndpoint', false, 'security'],
        ['isMethod', false, 'security'],
        ['isDoc', false, 'security'],
        ['isType', false, 'security'],
        ['isSecurity', true, 'security'],
        ['isSummary', false, 'security'],
      ].forEach((item) => testVarState(item));
    });
    suite('DOM content', () => {
      function testPresent(item) {
        test(item[0] + ' is in the DOM', (done) => {
          const element = fixture('Basic');
          element.amfModel = amf;
          element.selectedType = item[1];
          flush(() => {
            const node = element.shadowRoot.querySelector(item[0]);
            assert.ok(node);
            done();
          });
        });
      }

      [
        ['api-summary', 'summary'],
        ['api-endpoint-documentation', 'endpoint'],
        ['api-method-documentation', 'method'],
        ['api-documentation-document', 'documentation'],
        ['api-type-documentation', 'type'],
        ['api-security-documentation', 'security']
      ].forEach((item) => testPresent(item));
    });
  });

  suite('Data computation', () => {
    suite('Regular model', () => {
      let amf;
      suiteSetup(() => {
        return AmfLoader.load()
        .then((data) => {
          amf = data;
        });
      });

      suite('_updateEndpoint()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Computes model for endpoint selection', () => {
          const endpoint = endpoints[0];
          element.selected = endpoint['@id'];
          element._setIsEndpoint(true);

          assert.typeOf(element.endpoint, 'object');
          assert.equal(element.endpoint['@id'], endpoint['@id']);
        });

        test('Computes model for method selection', () => {
          const endpoint = endpoints[0];
          const endpointId = endpoint['@id'];
          const ops = element._computeOperations(webApi, endpointId);
          element.selected = ops[0]['@id'];
          element._setIsMethod(true);

          assert.typeOf(element.endpoint, 'object');
          assert.equal(element.endpoint['@id'], endpoint['@id']);
        });
      });

      suite('_computeMethodNext()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeMethodNext(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodNext(webApi, ops[0]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Create a person');
          assert.equal(result.id, ops[1]['@id']);
        });

        test('Does not compute next method link when last method', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodNext(webApi, ops[2]['@id']);
          assert.isUndefined(result);
        });
      });

      suite('_computeMethodPrevious()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeMethodPrevious(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes previous method link', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodPrevious(webApi, ops[1]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'List people');
          assert.equal(result.id, ops[0]['@id']);
        });

        test('Does not compute previous method link when last method', function() {
          const ops = element._computeOperations(webApi, endpoints[0]['@id']);
          const result = element._computeMethodPrevious(webApi, ops[0]['@id']);
          assert.isUndefined(result);
        });
      });

      suite('_computeEndpointNext()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeEndpointNext(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link', function() {
          const result = element._computeEndpointNext(webApi, endpoints[3]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Products');
          assert.equal(result.id, endpoints[4]['@id']);
        });

        test('Does not compute next method link when last method', function() {
          const result = element._computeEndpointNext(webApi, endpoints[12]['@id']);
          assert.isUndefined(result);
        });
      });

      suite('_computeEndpointPrevious()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeEndpointPrevious(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link', function() {
          const result = element._computeEndpointPrevious(webApi, endpoints[5]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Products');
          assert.equal(result.id, endpoints[4]['@id']);
        });

        test('Does not compute next method link when last method', function() {
          const result = element._computeEndpointPrevious(webApi, endpoints[0]['@id']);
          assert.isUndefined(result);
        });
      });
    });

    suite('Compact model', () => {
      let amf;
      suiteSetup(() => {
        return AmfLoader.load(true)
        .then((data) => {
          amf = data;
        });
      });

      suite('_updateEndpoint()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Computes model for endpoint selection', () => {
          const endpoint = endpoints[0];
          element.selected = endpoint['@id'];
          element._setIsEndpoint(true);

          assert.typeOf(element.endpoint, 'object');
          assert.equal(element.endpoint['@id'], endpoint['@id']);
        });

        test('Computes model for method selection', () => {
          const endpoint = endpoints[0];
          const endpointId = endpoint['@id'];
          const ops = element._computeOperations(webApi, endpointId);
          element.selected = ops[0]['@id'];
          element._setIsMethod(true);

          assert.typeOf(element.endpoint, 'object');
          assert.equal(element.endpoint['@id'], endpoint['@id']);
        });
      });

      suite('_computeMethodNext()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeMethodNext(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodNext(webApi, ops[0]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Create a person');
          assert.equal(result.id, ops[1]['@id']);
        });

        test('Does not compute next method link when last method', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodNext(webApi, ops[2]['@id']);
          assert.isUndefined(result);
        });
      });

      suite('_computeMethodPrevious()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeMethodPrevious(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes previous method link', function() {
          const ops = element._computeOperations(webApi, endpoints[2]['@id']);
          const result = element._computeMethodPrevious(webApi, ops[1]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'List people');
          assert.equal(result.id, ops[0]['@id']);
        });

        test('Does not compute previous method link when last method', function() {
          const ops = element._computeOperations(webApi, endpoints[0]['@id']);
          const result = element._computeMethodPrevious(webApi, ops[0]['@id']);
          assert.isUndefined(result);
        });
      });

      suite('_computeEndpointNext()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeEndpointNext(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link', function() {
          const result = element._computeEndpointNext(webApi, endpoints[3]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Products');
          assert.equal(result.id, endpoints[4]['@id']);
        });

        test('Does not compute next method link when last method', function() {
          const result = element._computeEndpointNext(webApi, endpoints[12]['@id']);
          assert.isUndefined(result);
        });
      });

      suite('_computeEndpointPrevious()', function() {
        let endpoints;
        let element;
        let webApi;
        setup(() => {
          element = fixture('Basic');
          element.amfModel = amf;
          webApi = element._computeWebApi(amf);
          endpoints = element._computeEndpoints(webApi);
        });

        test('Returns undefined when no selected', function() {
          const result = element._computeEndpointPrevious(webApi, 'nothing');
          assert.isUndefined(result);
        });

        test('Computes next method link', function() {
          const result = element._computeEndpointPrevious(webApi, endpoints[5]['@id']);
          assert.typeOf(result, 'object');
          assert.equal(result.label, 'Products');
          assert.equal(result.id, endpoints[4]['@id']);
        });

        test('Does not compute next method link when last method', function() {
          const result = element._computeEndpointPrevious(webApi, endpoints[0]['@id']);
          assert.isUndefined(result);
        });
      });
    });
  });

  suite('handleNavigationEvents property', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Calls _registerNavigationEvents() when state is set', () => {
      const spy = sinon.spy(element, '_registerNavigationEvents');
      element.handleNavigationEvents = true;
      assert.isTrue(spy.called);
    });

    test('Sets __eventsRegistered flag', () => {
      element.handleNavigationEvents = true;
      assert.isTrue(element.__eventsRegistered);
    });

    test('Calls _unregisterNavigationEvents() when state is set', () => {
      element.handleNavigationEvents = true;
      const spy = sinon.spy(element, '_unregisterNavigationEvents');
      element.handleNavigationEvents = false;
      assert.isTrue(spy.called);
    });

    test('Sets __eventsRegistered flag', () => {
      element.handleNavigationEvents = true;
      element.handleNavigationEvents = false;
      assert.isFalse(element.__eventsRegistered);
    });

    test('Updates selection from the event', () => {
      element.handleNavigationEvents = true;
      document.body.dispatchEvent(new CustomEvent('api-navigation-selection-changed', {
        bubbles: true,
        detail: {
          selected: 'summary',
          type: 'summary'
        }
      }));
      assert.equal(element.selected, 'summary');
      assert.equal(element.selectedType, 'summary');
    });

    test('Ignores passive events', () => {
      element.handleNavigationEvents = true;
      document.body.dispatchEvent(new CustomEvent('api-navigation-selection-changed', {
        bubbles: true,
        detail: {
          selected: 'summary',
          type: 'summary',
          passive: true
        }
      }));
      assert.isUndefined(element.selected);
      assert.isUndefined(element.selectedType);
    });
  });

  suite('Security scheme rendering', () => {
    function getScheme(element, name) {
      const declares = element._computeDeclares(element.amfModel);
      for (let i = 0; i < declares.length; i++) {
        const item = declares[i];
        if (element._hasType(item, element.ns.raml.vocabularies.security + 'SecurityScheme')) {
          const value = element._getValue(item, element.ns.raml.vocabularies.security + 'name');
          if (value === name) {
            return item;
          }
        }
      }
    }
    [
      ['Full model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let element;
        setup(() => {
          element = fixture('Basic');
          return AmfLoader.load(item[1])
          .then((data) => {
            element.amfModel = data;
          });
        });

        test('Renders security scheme', (done) => {
          const scheme = getScheme(element, 'oauth_2_0');
          const id = scheme['@id'];
          element.selected = id;
          element.selectedType = 'security';
          flush(() => {
            const node = element.shadowRoot.querySelector('api-security-documentation');
            assert.ok(node);
            done();
          });
        });

        test('Scheme is computed and set on panel', (done) => {
          const scheme = getScheme(element, 'oauth_2_0');
          const id = scheme['@id'];
          element.selected = id;
          element.selectedType = 'security';
          flush(() => {
            const node = element.shadowRoot.querySelector('api-security-documentation');
            assert.typeOf(node.security, 'object');
            assert.isTrue(node.security === scheme);
            done();
          });
        });
      });
    });
  });

  suite('RAML library rendering', () => {
    function getScheme(element, name) {
      const declares = element._computeDeclares(element.amfModel);
      for (let i = 0; i < declares.length; i++) {
        const item = declares[i];
        if (element._hasType(item, element.ns.raml.vocabularies.security + 'SecurityScheme')) {
          const value = element._getValue(item, element.ns.raml.vocabularies.security + 'name');
          if (value === name) {
            return item;
          }
        }
      }
    }

    function getType(element, name) {
      const declares = element._computeDeclares(element.amfModel);
      for (let i = 0; i < declares.length; i++) {
        const item = declares[i];
        if (element._hasType(item, element.ns.w3.shacl.name + 'NodeShape')) {
          const value = element._getValue(item, element.ns.w3.shacl.name + 'name');
          if (value === name) {
            return item;
          }
        }
      }
    }
    [
      ['Full model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let element;
        setup(() => {
          element = fixture('Basic');
          return AmfLoader.load(item[1], 'lib-fragment')
          .then((data) => {
            element.amfModel = data;
          });
        });

        test('Renders security scheme from a library', (done) => {
          const scheme = getScheme(element, 'OAuth1');
          const id = scheme['@id'];
          element.selected = id;
          element.selectedType = 'security';
          flush(() => {
            const node = element.shadowRoot.querySelector('api-security-documentation');
            assert.ok(node);
            done();
          });
        });

        test('Renders type from a library', (done) => {
          const scheme = getType(element, 'myType');
          const id = scheme['@id'];
          element.selected = id;
          element.selectedType = 'type';
          flush(() => {
            const node = element.shadowRoot.querySelector('api-type-documentation');
            assert.ok(node);
            done();
          });
        });
      });
    });
  });
  </script>
</body>

</html>
