<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/elements/dom-if.html">
<link rel="import" href="../polymer/lib/utils/render-status.html">
<link rel="import" href="../raml-aware/raml-aware.html">
<link rel="import" href="../api-endpoint-documentation/api-endpoint-documentation.html">
<link rel="import" href="../api-type-documentation/api-type-documentation.html">
<link rel="import" href="../api-documentation-document/api-documentation-document.html">
<link rel="import" href="../api-method-documentation/api-method-documentation.html">
<link rel="import" href="../api-summary/api-summary.html">
<link rel="import" href="../api-security-documentation/api-security-documentation.html">
<link rel="import" href="../amf-helper-mixin/amf-helper-mixin.html">

<dom-module id="api-documentation">
  <template>
    <style>
    :host {
      display: block;
      @apply --api-documentation;
    }
    </style>
    <template is="dom-if" if="[[aware]]">
      <raml-aware raml="{{amfModel}}" scope="[[aware]]"></raml-aware>
    </template>
    <template is="dom-if" if="[[isSummary]]" restamp="true">
      <api-summary amf-model="[[amfModel]]" base-uri="[[baseUri]]"></api-summary>
    </template>
    <template is="dom-if" if="[[isSecurity]]" restamp="true">
      <api-security-documentation amf-model="{{amfModel}}" security="[[_computeSecurityModel(declares, selected)]]"></api-security-documentation>
    </template>
    <template is="dom-if" if="[[isEndpoint]]" restamp="true">
      <api-endpoint-documentation amf-model="{{amfModel}}" endpoint="[[_computeEndpointModel(webApi, selected)]]" previous="[[_computeEndpointPrevious(webApi, selected)]]" next="[[_computeEndpointNext(webApi, selected)]]" base-uri="[[baseUri]]" narrow="[[narrow]]" narrow="[[narrow]]"></api-endpoint-documentation>
    </template>
    <template is="dom-if" if="[[isMethod]]" restamp="true">
      <api-method-documentation amf-model="{{amfModel}}" endpoint="[[_computeMethodEndpointModel(webApi, selected)]]" method="[[_computeMethodModel(webApi, selected)]]" previous="[[_computeMethodPrevious(webApi, selected)]]" next="[[_computeMethodNext(webApi, selected)]]" base-uri="[[baseUri]]" no-try-it="[[noTryIt]]" narrow="[[narrow]]"></api-method-documentation>
    </template>
    <template is="dom-if" if="[[isDoc]]" restamp="true">
      <api-documentation-document api-document="[[_computeDocument(webApi, selected)]]"></api-documentation-document>
    </template>
    <template is="dom-if" if="[[isType]]" restamp="true">
      <api-type-documentation amf-model="{{amfModel}}" type="[[_computeType(declares, references, selected)]]"></api-type-documentation>
    </template>
  </template>
  <script>
  /**
   * `api-documentation`
   *
   * A main documentation view for AMF model.
   *
   * This element works with [AMF](https://github.com/mulesoft/amf) data model.
   *
   * It works well with `api-navigation` component. When `handle-navigation-events`
   * is set it listens for selection events dispatched by the navigation.
   *
   * To manually steare the behavior of the component you have to set both:
   * - selected
   * - selectedType
   *
   * Selected is an `@id` of the AMF data model in json/ld representation.
   * Selected type tells the component where to look for the data and which
   * view to render.
   *
   * The component handles data computation on selection change.
   *
   * ## Updating API's base URI
   *
   * By default the component render the documentation as it is defined
   * in the AMF model. Sometimes, however, you may need to replace the base URI
   * of the API with something else. It is useful when the API does not
   * have base URI property defined (therefore this component render relative
   * paths instead of URIs) or when you want to manage different environments.
   *
   * To update base URI value either update `baseUri` property or use
   * `iron-meta` with key `ApiBaseUri`. First method is easier but the second
   * gives much more flexibility since it use a [monostate pattern](http://wiki.c2.com/?MonostatePattern)
   * to manage base URI property.
   *
   * When the component constructs the funal URI for the endpoint it does the following:
   * - if `baseUri` is set it uses this value as a base uri for the endpoint
   * - else if `iron-meta` with key `ApiBaseUri` exists and contains a value
   * it uses it uses this value as a base uri for the endpoint
   * - else if `amfModel` is set then it computes base uri value from main
   * model document
   * Then it concatenates computed base URI with `endpoint`'s path property.
   *
   * ### Example
   *
   * ```html
   * <iron-meta key="ApiBaseUri" value="https://domain.com"></iron-meta>
   * ```
   *
   * To update value of the `iron-meta`:
   * ```javascript
   * new Polymer.IronMeta({key: 'ApiBaseUri'}).value = 'https://other.domain';
   * ```
   *
   * Note: The element will not get notified about the change in `iron-meta`.
   * The change will be reflected whehn `amfModel` or `endpoint` property chnage.
   *
   * ## Styling
   *
   * `<api-documentation>` provides the following custom properties and mixins for styling:
   *
   * Custom property | Description | Default
   * ----------------|-------------|----------
   * `--api-documentation` | Mixin applied to this elment | `{}`
   *
   * @customElement
   * @polymer
   * @demo demo/index.html
   * @memberof ApiElements
   * @appliesMixin ApiElements.AmfHelperMixin
   */
  class ApiDocumentation extends ApiElements.AmfHelperMixin(Polymer.Element) {
    static get is() { return 'api-documentation'; }
    static get properties() {
      return {
        /**
         * `raml-aware` scope property to use.
         */
        aware: String,
        /**
         * A model's `@id` of selected documentation part.
         * Special case is for `summary` view. It's not part of an API
         * but most applications has some kind of summary view for the
         * API.
         */
        selected: String,
        /**
         * Type of the selected item.
         * One of `documentation`, `type`, `security`, `endpoint`, `method`
         * or `summary`.
         */
        selectedType: String,
        /**
         * By default application hosting the element must set `selected` and
         * `selectedType` properties. When using `api-navigation` element
         * by setting this property the element listens for navigation events
         * and updates the state
         */
        handleNavigationEvents: {
          type: Boolean,
          observer: '_handleNavChanged'
        },
        // True if currently selection is endpoint
        isEndpoint: {
          type: Boolean,
          readOnly: true,
          observer: '_isEndpointChanged'
        },
        // True if currently selection is method
        isMethod: {
          type: Boolean,
          readOnly: true
        },
        // True if currently selection is documentation
        isDoc: {
          type: Boolean,
          readOnly: true
        },
        // True if currently selection is type
        isType: {
          type: Boolean,
          readOnly: true
        },
        // True if currently selection is security
        isSecurity: {
          type: Boolean,
          readOnly: true
        },
        // True if currently selection is summary
        isSummary: {
          type: Boolean,
          readOnly: true
        },
        /**
         * Computed value of AMF model of a type of `http://schema.org/WebAPI`
         *
         * @type {Object}
         */
        webApi: {
          type: Object,
          computed: '_computeWebApi(amfModel)'
        },
        /**
         * Computed value of `declares` part of the AMF model
         *
         * @type {Array<Object>}
         */
        declares: {
          type: Array,
          computed: '_computeDeclares(amfModel)'
        },
        /**
         * Computed value of `references` part of the AMF model
         *
         * @type {Array<Object>}
         */
        references: {
          type: Array,
          computed: '_computeReferences(amfModel)'
        },
        /**
         * A property to set to override AMF's model base URI information.
         */
        baseUri: String,
        /**
         * Passing value of `noTryIt` to the method documentation.
         * Hiddes "Try it" button.
         */
        noTryIt: Boolean,
        /**
         * If set it will renders the view in the narrow layout.
         */
        narrow: {
          type: Boolean,
          reflectToAttribute: true
        }
      };
    }

    static get observers() {
      return [
        '_navigationOccured(selectedType)'
      ];
    }

    constructor() {
      super();
      this._navigationHandler = this._navigationHandler.bind(this);
    }

    disconnectedCallback() {
      if (this.__eventsRegistered) {
        this._unregisterNavigationEvents();
      }
    }
    /**
     * Registers `api-navigation-selection-changed` event listener handler
     * on window object.
     */
    _registerNavigationEvents() {
      this.__eventsRegistered = true;
      window.addEventListener('api-navigation-selection-changed', this._navigationHandler);
    }
    /**
     * Removes event listener from window object for
     * `api-navigation-selection-changed` event.
     */
    _unregisterNavigationEvents() {
      this.__eventsRegistered = false;
      window.removeEventListener('api-navigation-selection-changed', this._navigationHandler);
    }
    /**
     * Registers / unregisters event listeners depending on `state`
     *
     * @param {Boolean} state
     */
    _handleNavChanged(state) {
      if (state) {
        this._registerNavigationEvents();
      } else {
        this._unregisterNavigationEvents();
      }
    }
    /**
     * Handler for `api-navigation-selection-changed` event.
     *
     * @param {CustomEvent} e
     */
    _navigationHandler(e) {
      if (e.detail.passive === true) {
        return;
      }
      this.selected = e.detail.selected;
      this.selectedType = e.detail.type;
    }
    /**
     * Handles navigation change, computes model for the view and finally
     * renders the view.
     * @param {String} selectedType
     */
    _navigationOccured(selectedType) {
      console.log(selectedType);
      this._setIsEndpoint(selectedType === 'endpoint');
      this._setIsMethod(selectedType === 'method');
      this._setIsDoc(selectedType === 'documentation');
      this._setIsType(selectedType === 'type');
      this._setIsSecurity(selectedType === 'security');
      this._setIsSummary(selectedType === 'summary');
    }

    _computeEndpointLink(item) {
      if (!item) {
        return;
      }
      let name = this._getValue(item, this.ns.schema.schemaName);
      if (!name) {
        name = this._getValue(item, this.ns.raml.vocabularies.http + 'path');
      }
      return {
        id: item['@id'],
        label: name
      };
    }

    _computeEndpointPrevious(webApi, selected) {
      if (!webApi || !selected) {
        return;
      }
      const endpoints = webApi[this.ns.raml.vocabularies.http + 'endpoint'];
      for (let i = 0; i < endpoints.length; i++) {
        if (endpoints[i]['@id'] === selected) {
          return this._computeEndpointLink(endpoints[i - 1]);
        }
      }
    }

    _computeEndpointNext(webApi, selected) {
      if (!webApi || !selected) {
        return;
      }
      const endpoints = webApi[this.ns.raml.vocabularies.http + 'endpoint'];
      for (let i = 0; i < endpoints.length; i++) {
        if (endpoints[i]['@id'] === selected) {
          return this._computeEndpointLink(endpoints[i + 1]);
        }
      }
    }
    /**
     * Computes model for endpoint for method documentation.
     *
     * @param {Object} webApi Current value of `webApi` property
     * @param {String} selected Selected shape
     * @return {Object} An endponit definition
     */
    _computeMethodEndpointModel(webApi, selected) {
      if (!webApi || !selected) {
        return;
      }
      const endpointId = selected.substr(0, selected.lastIndexOf('/'));
      return this._computeEndpointModel(webApi, endpointId);
    }

    _computeMethodLink(item) {
      if (!item) {
        return;
      }
      let name = this._getValue(item, this.ns.schema.schemaName);
      if (!name) {
        name = this._getValue(item, this.ns.w3.hydra.core + 'method');
      }
      return {
        id: item['@id'],
        label: name
      };
    }

    _computeMethodPrevious(webApi, selected) {
      const methods = this.__computeMethodsListForMethod(webApi, selected);
      if (!methods) {
        return;
      }
      for (let i = 0; i < methods.length; i++) {
        if (methods[i]['@id'] === selected) {
          return this._computeMethodLink(methods[i - 1]);
        }
      }
    }

    _computeMethodNext(webApi, selected) {
      const methods = this.__computeMethodsListForMethod(webApi, selected);
      if (!methods) {
        return;
      }
      for (let i = 0; i < methods.length; i++) {
        if (methods[i]['@id'] === selected) {
          return this._computeMethodLink(methods[i + 1]);
        }
      }
    }

    _isEndpointChanged(is) {
      if (!is) {
        return;
      }
      Polymer.RenderStatus.afterNextRender(this, () => {
        const node = this.shadowRoot.querySelector('api-endpoint-documentation');
        if (!node) {
          return;
        }
        let options;
        if ('scrollBehavior' in document.documentElement.style) {
          options = {
            block: 'start',
            inline: 'nearest'
          };
        } else {
          options = true;
        }
        node.scrollIntoView(options);
      });
    }
  }
  window.customElements.define(ApiDocumentation.is, ApiDocumentation);
  </script>
</dom-module>
